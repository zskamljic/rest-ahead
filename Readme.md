# RestAhead - compile time generated REST client

This project draws inspiration from projects such as [Retrofit](https://square.github.io/retrofit/)
and [Feign](https://github.com/OpenFeign/feign), but with a twist: your services are generated at compile time,
preventing any issues from being found at runtime.

The aim of this project is to have as much validation done at compile time, rather than runtime. Additionally, since the
code is generated at compile time there is no need for reflection. The generated code can be inspected for a no-magic
approach.

## Features

- [Adapters](#adapters)
- [Body](#body)
- [Headers](#headers)
- [Interceptors](#interceptors)
- [Path](#paths)
- [Query](#queries)
- [Responses](#response-types)

## Introduction

Much like other clients, the service is declared as following:

```java
public interface HttpBinService {
    @Get("/get")
    Future<Response> performGet();
}
```

An instance of this class can be generated by using RestAhead class.

```jshelllanguage
var service = RestAhead.builder("https://httpbin.org")
    .build(HttpBinService.class);
```

Calls can then be performed simply by calling the instance of the interface:

```jshelllanguage
var response = service.performGet();
```

Samples of services can be found in `demo` project [here](demo/src/main/java/io/github/zskamljic/restahead/demo/clients)
, examples of obtaining their instances are
in [this directory](demo/src/test/java/io/github/zskamljic/restahead/demo/clients).

## Options

There are multiple options you have when generating requests, all of which will be done automatically when building your
project.

### Response types

Out of the box the following types are supported:

- void
- Response
- Future&lt;Response&gt;
- CompletableFuture&lt;Response&gt;

Other types require you to specify an instance of Converter (rest-ahead-jackson-converter contains an implementation for
Jackson library). This will allow you to use virtually any type that the converter can construct.

Example of using a return type:

```java
interface Service {
    @Get
    void requestIgnoringResponse();

    @Get
    Response requestFullResponse();

    @Get
    Map<String, Object> performGet();

    @Get
    CustomResponseType performGetWithSpecificTarget();
}
```

### Body

You can specify a request body by annotating it with `@Body`. Doing so will make the service require a converter to
serialize the body.

```java
public interface HttpBinService {
    @Post("/post")
    Future<Response> performPost(@Body CustomRequest request);
}
```

Sending a form-url-encoded body can be done by adding `@FormUrlEncoded` annotation to the body:

```java
public interface HttpBinService {
    @Post("/post")
    Future<Response> performPost(@FormUrlEncoded @Body CustomRequest request);
}
```

Such bodies do not require a converter, one will be generated for the given type.

Supported types:

- Map<String, String> and inherited classes
- Records composed of primitives, boxed values, String or UUID
- Classes with public, non-static getters returning only primitives, boxed values, String or UUID

### Headers

Adding headers is possible by using the `@Header` annotation. Valid parameters for headers are either primitive types,
their boxed counterparts, Strings, instances of UUID or collections/arrays of them.

Using multiple annotations with the same value will add extra headers. The following declarations will generate requests
that behave the same:

```java
interface Service {
    @Get
    void performGet(@Header("Some-Header") String first, @Header("Some-Header") String second);

    @Get
    void performGetVarargs(@Header("Some-Header") String... headers);

    @Get
    void performGetArray(@Header("Some-Header") String[] headers);

    // Can also use List, Set etc.
    @Get
    void performGetCollection(@Header("Some-Header") Collection<String> headers);
}
```

### Queries

Queries can be added to a request in two ways, seen below. Collections, arrays and varargs types are allowed.

```java
interface Service {
    @Get("/query?q=value")
    void getWithQuery(); // will use the preset value from path

    @Get("/query")
    void getWithParam(@Query("q") String query); // will use the parameter
}
```

### Adapters

The default type for all services is `Future<Response>`. While the value can be mapped to `Future<YourObject>` using a
converter directly, sometimes interop with other libraries is required, or maybe you need a blocking call and don't want
to type `.get()` all the time, as well as catch the exceptions. For these cases a default adapter is included, to allow
for blocking calls as evident here:

```java
import java.util.concurrent.CompletableFuture;

interface SampleBlocking {
    @Get
    Future<Response> getFuture();

    @Get
    CompletableFuture<Response> getCompletableFuture();

    @Get
    Response getBlocking();
}
```

All three examples above will perform the same request, but `Future` and `CompletableFuture` will attempt to do this in
non-blocking manner (this depends on the client, default JavaHttpClient supports this), but the last, `Response` will
execute a blocking call.

If you wish to declare your own adapters simply create a class with a method annotated with `@Adapter`:

```java
public class CustomAdapter {
    @Adapter
    public <T> Supplier<T> adapt(Future<T> future) {
        return () -> {
            try {
                return future.get();
            } catch (InterruptedException | ExecutionException e) {
                throw new RestException(e);
            }
        };
    }
}
```

Adapter will also need to be added to RestAhead builder, via the `addAdapter(Object object)` method. Exceptions can be
thrown by declared adapters and can be propagated via the service (see [Call exceptions](#call-exceptions)).

### Interceptors

Interceptors can be added to the client to perform common logic before, after or around a request. Interceptor should
implement the `Interceptor` interface and be added to the client like so:

```jshelllanguage
var client = new JavaHttpClient();
    client.addInterceptor(new PreRequestInterceptor());

    var service = RestAhead.builder("https://httpbin.org/")
        .client(client)
        .converter(new JacksonConverter())
        .build(InterceptedService.class);
```

### Paths

Path parameters can also be provided through requests by using the `@Path` annotation on a parameter:

```java
interface PathExample {
    @Get("/{path1}/{path2}")
    Response performGet(@Path("path1") String path, @Path String path2); // value can be omitted in favor or parameter name
}
```

### Call exceptions

By default, no exceptions need to be declared to execute calls, but beware! An unchecked exception (RestException) will
be thrown in case there was an exception thrown during execution. You can also add `throws` declaration for either or
both exceptions that are likely to occur: `ExecutionException`, `InterruptedException`, to make sure they are handled.
If either of these is not specified in the signature, `RestException` will still be thrown, wrapping the other one, for
example:

```java
import java.util.concurrent.ExecutionException;

public interface HttpBinService {
    // Will throw a RestException if any errors occur
    @Get("/get")
    Response performGet();

    // Allows you to handle IOException, RestException wrapping InterruptedException may still occur
    @Get("/get")
    Response performGet2() throws ExecutionException;

    // Allows you to handle both exception, no RestException will be thrown
    @Get("/get")
    Response performGet3() throws ExecutionException, InterruptedException;
}
```

A failed request, with custom responses will throw RequestFailedException, that contains a code and the input stream
from the request.

### Custom client

The `RestAhead` builder declares an interface `Client` that allows you to implement custom clients. By default, if no
client is specified, Java HTTP client is used.

## License

Project uses Apache 2.0 license. More info in [license file](LICENSE)